##### 1.云计算的三种基本类型
软件即服务（SaaS）基于互联网提供软件服务的软件应用模式，企业通过租赁的形式使用信息系统，无需购买软硬件、建设机房、招聘 IT 人员等。
平台即服务（PaaS）将服务器平台或开发环境等作为一种服务提供给用户，加快 SaaS 应用的开发速度。
基础设施即服务（IaaS）通过互联网获得完善的计算机基础设施服务，如云服务器等。

##### 2 .分布式系统中中间件的两种不同类型
<u>支持交互支持和提供公共服务</u>。交互支持指协调不同组件之间的交互，而提供公共服务则指提供对服务可复用的实现，被不同组件需求的服务。公共服务可以在中间件容器中提供，被部署在容器中的组件可以访问和使用这些公共服务。

##### 3.微服务架构（Microservices）和面向服务的架构（SOA）
微服务架构使用去中心化的扁平化管理方式，每个服务都是一个独立的应用程序，独立管理、使用独立的数据库、独立部署和独立运行。
面向服务的架构（SOA） 是一种整体式架构，使用集中式的管理方式和统一的数据中心。

##### 4 .多视图
多视图指从不同角度和视角描述系统体系结构，以获得多个视图，并将其组合在一起以描述整体模型。<u>多视图反映了关注点分离的思想，每个视图只关注系统的一个侧面。</u>

##### 5 .“4+1”视图
**版本一**
“4+1”视图模型是描述软件体系结构的常用模型，涵盖<u>逻辑视图、进程视图、物理视图、开发视图和场景视图</u>，每个视图只反映某个侧面。在此模型中，“1” 指的是统一场景。
![[Pasted image 20240628101157.png]]
**逻辑视图**用于描述系统的功能需求，采用面向对象的风格，用类图描述；  
**开发视图**侧重于模块的组织和管理，通过系统I/O关系的模型图和子系统图来描述；  
**进程视图**关注系统的运行特性，强调并发性、分布性、系统集成性和容错能力；  
**物理视图**考虑将软件映射到硬件上，需要有较高的灵活性；  
**场景视图**则对应用例视图，对系统重要活动进行抽象描述，有利于构件及其相互关系的分析。  
**类图**是从开发视角对软件系统进行描述。

**版本二**
逻辑视图和实现视图类似于“4+1”模型中的逻辑视图和开发视图，都是描述软件系统的功能和逻辑结构。部署视图和物理视图都是描述系统的部署和物理环境，进程视图则是描述系统中各个进程的组合和交互。这种视图模型在软件架构中也比较常见，但是具体使用要根据实际情况和需求进行调整和改进。
![[Pasted image 20240628101419.png]]

##### 6 .基于体系结构的软件设计（ABSD）
1. ABSD 方法强调由<u>商业、质量和功能需求</u>的组合驱动软件架构设计。  
2. 它强调采用<u>视角和视图</u>来描述软件架构，采用<u>用例和质量场景</u>来描述需求。  
3. ABSD 是一个自顶向下，递归细化的软件开发方法，软件系统的体系结构通过该方法得到细化，直到能产生软件构件和类。在最顶层，系统被分解为若干概念子系统和一个或若干个软件模板。在第2层，概念子系统又被分解成概念构件和一个或若干个附加软件模板。体系结构需求一般来自3个方面，分别是系统的质量目标、系统的商业目标和系统开发人员的商业目标。  
4. 它以软件系统功能的分解为基础，通过选择架构风格实现质量和商业需求，并强调在架构设计过程中使用软件架构模板。 
 ![[Pasted image 20240710164712.png]]
**ABSD方法有三个基础**  
- 第一个基础是功能分解，在功能分解中使用已有的基于模块的内聚和耦合技术。  
- 第二个基础是通过选择体系结构风格来实现质量和商业需求。  
- 第三个基础是软件模板的使用。
**ABSD 方法中的视角和视图**
**不同视角（Perspectives）**
1. **静态视角**：
    - 展示功能组织，判断质量特性。
2. **动态视角**：
    - 展示并发行为，判断系统行为特性。
**特定视图（Views）**
1. **逻辑视图**：
    - 记录功能和概念接口，定义设计元素角色。
2. **进程视图**：
    - 描述并发和同步特性。
3. **实现视图**：
    - 展示模块和组件的物理实现。
4. **配置视图**：
    - 描述系统的物理部署和环境配置。

##### 7.软件体系结构风格
软件体系结构风格是描述特定应用领域中系统组织方式的惯用模式。<u>它定义了一个词汇表和一组约束，包含构件和连接件类型，指导系统如何将它们组合起来</u>。这种风格反映了领域中众多系统的<u>结构和语义特性</u>，有助于有效地组织各个模块和子系统成为完整的系统。研究和实践软件体系结构风格可以促进设计的重用，通过实践验证的解决方案也可以可靠地应用于解决新的问题。
![[Pasted image 20240708103944.png]]

**批处理风格**
批处理风格的软件体系结构主要特征是将数据处理任务分割成一系列独立的步骤，每个步骤处理完成后，输出数据成为下一个步骤的输入数据。这种风格适用于数据量大、处理逻辑相对简单、对实时性要求不高的场景。批处理系统的典型应用包括：
- 经典数据处理任务，如大数据分析、报表生成等。
- 程序开发中的编译、链接等过程。
- 操作系统中的BAT程序或Shell脚本，用于自动化执行一系列命令。
批处理风格的主要优势在于简单、易于实现，并且可通过增加处理步骤的并行性来提高性能。然而，其缺点是缺乏交互性，一旦开始执行，中间环节难以调整。

**虚拟机风格**
虚拟机风格的软件体系结构通过创建一个抽象的、与硬件无关的运行环境，来解析和执行一种或多种自定义语言的程序。这种风格的软件体系结构扩展性强，增强了系统与不同硬件平台之间的兼容性，减轻了开发者对硬件特性的依赖。虚拟机风格的典型应用包括：
- 编程语言的解释器，如Python、Ruby的解释环境。
- <u>基于规则</u>的专家系统，这些系统通过规则解释器来执行规则集，进行决策支持或知识推理。
- 虚拟机软件，如Java虚拟机（JVM），提供了一个跨平台的运行环境，能够运行编译后的Java程序。
虚拟机风格最大的优点是其跨平台性、灵活性和扩展性。但是，可能因为解释或模拟执行而导致运行效率低于直接在物理机上执行。

**规则系统体系风格(虚拟机风格)**
特别强调将业务逻辑、决策逻辑或专家知识以规则的形式进行表达和存储。在这种系统中，规则作为中心元素，用于指导系统的行为或作出决策。这种架构风格的主要组成部分包括：
1. **规则库（Rule Base）**：包含所有定义好的规则，这是系统决策逻辑的核心。规则通常以“如果-那么”（IF-THEN）的形式存在，描述了在特定条件下应该执行的行动或结论。
2. **规则解释器（Rule Interpreter）**：负责解释规则库中的规则，并根据当前上下文数据来应用这些规则。它处理规则的选择、优先级及其执行顺序。
3. **工作内存（Working Memory）**：存放当前的事实和数据，供规则解释器使用。这部分数据通常在系统运行过程中不断更新，以反映外部环境的变化或是内部处理的中间结果。
4. **规则/数据选择器（Rule/Data Selector）**：用于选择和过滤哪些规则适用于当前的上下文和数据状态。这有助于提高系统的运行效率，避免无谓的规则处理。
5. **推理机械（Inference Engine）**：虽然有时候和规则解释器视为同一组件，但推理机更注重于如何基于工作内存中的数据和规则库进行逻辑推理，包括正向推理（从已知事实推导新事实）和反向推理（从期望结果逆推需要的条件）。
6. **用户接口（User Interface）**：允许用户与系统交互，可以是图形界面、命令行或其他形式，用于输入事实和查询系统决策结果。
规则系统的优势在于它们的灵活性和可扩展性——向规则库中添加、修改或删除规则往往比改变传统程序代码更为简单直接。此外，该风格的系统通过将知识以规则的形式明确表示，提高了系统决策逻辑的透明度和可解释性。
然而，规则系统也有其局限，如随着规则数量的增加，系统的性能可能下降，特别是当规则之间存在冲突或依赖时，维护和调试可能会变得复杂。因此，设计时需要仔细考虑规则系统的规模、规则管理策略以及优化推理策略。

**仓库风格**
它将系统的数据存储在一个中心化的仓库中，由多个独立的构件通过这个仓库进行交互和操作。
**核心概念**
1. **中央数据结构（仓库）**：
    - 是存储和维护所有系统数据的中心场所。
    - 描述当前数据的状态。
2. **独立构件**：
    - 一组对中央数据进行操作的构件。
    - 这些构件独立于彼此，仅通过仓库进行交互。
3. **连接件**：
    - 仓库与独立构件之间的交互机制。
    - 定义了构件如何访问和操作仓库中的数据。
**特点**
- **集中化的数据管理**：
    - 所有的数据存储和管理都在仓库中集中进行。
    - 方便进行数据的一致性和完整性管理。
- **独立构件的松耦合**：
    - 各个独立构件之间没有直接的依赖关系，通过仓库进行间接交互。
    - 增加了系统的灵活性和可扩展性。
- **可扩展性**：
    - 新的独立构件可以很容易地添加到系统中，只需与仓库交互即可。
    - 适用于需要频繁添加或修改功能的系统。
**优点**
- **数据一致性**：
    - 数据集中管理，保证了一致性和完整性。
- **模块化**：
    - 各个独立构件可以独立开发、测试和部署，提高了系统的模块化水平。
- **灵活性**：
    - 由于构件之间松耦合，系统的功能可以灵活扩展和修改。
**缺点**
- **性能瓶颈**：
    - 中央仓库可能成为性能瓶颈，特别是在高并发访问的情况下。
- **单点故障**：
    - 仓库作为单点，如果出现故障，整个系统可能会受到影响。
**适用场景**
- **集成系统**：不同系统之间需要共享和集成数据。
- **数据密集型应用**：需要集中管理大量数据。
- **分布式系统**：多个分布式构件需要共享和访问统一的数据。

**黑板风格**
常用于解决复杂问题，特别是那些需要不同知识源协同工作的系统。以下是黑板风格的详细概述：
**核心概念**
1. **黑板（Blackboard）**：
    - 一个全局的数据结构，所有的信息和中间结果都存储在这里。
    - 各个模块通过读取和写入黑板来交换信息和协调工作。
2. **知识源（Knowledge Sources）**：
    - 一组独立的模块或代理，各自包含特定的知识或处理能力。
    - 它们独立工作，通过黑板来进行信息交流和协作。
3. **控制机制**：
    - 一个控制模块或机制，用于协调知识源的工作。
    - 决定哪些知识源在何时对黑板上的数据进行处理。
**工作流程**
1. **初始数据写入**：
    - 系统开始时，将初始数据写入黑板。
2. **知识源触发**：
    - 知识源监听黑板上的数据变化，当有相关数据时进行处理。
3. **更新黑板**：
    - 知识源处理数据后，将结果写回黑板。
4. **循环处理**：
    - 重复上述过程，直到达到最终目标或满足停止条件。
**特点**
- **松耦合**：
    - 各知识源之间没有直接依赖，通过黑板进行间接通信。
- **灵活性**：
    - 易于添加、移除或修改知识源，系统具有高灵活性。
- **适应性**：
    - 适用于不确定性高、需要不同领域知识协同解决的问题。
**优点**
- **模块化**：知识源可以独立开发和维护。
- **协作性**：各知识源通过黑板进行协作，解决复杂问题。
- **扩展性**：易于添加新知识源，增强系统功能。
**缺点**
- **性能开销**：频繁的黑板访问和数据处理可能带来性能问题。
- **控制复杂性**：需要复杂的控制机制来协调知识源的工作。
- **数据一致性**：黑板上的数据可能会因为并发访问而产生一致性问题。
**适用场景**
- **人工智能**：专家系统、推理系统等需要多种知识源协同工作的领域。
- **复杂系统**：需要整合多种技术或知识解决复杂问题的系统。

**管道-过滤器风格**
常用于数据流处理和转换。
**核心概念**
1. **过滤器（Filters）**：
    - 独立的处理单元，接收输入数据、处理数据，然后输出结果。
    - 过滤器只处理数据，不关心数据的来源和去向。
2. **管道（Pipes）**：
    - 数据传输通道，将一个过滤器的输出连接到下一个过滤器的输入。
    - 管道负责数据流动，确保数据从一个过滤器传递到下一个过滤器。
**工作流程**
1. **数据输入**：
    - 数据从源头进入第一个过滤器进行处理。
2. **数据处理**：
    - 过滤器接收输入数据，进行预定的处理操作（如转换、过滤、计算等），然后将结果输出到管道。
3. **数据传递**：
    - 管道将过滤器的输出数据传递到下一个过滤器的输入端。
4. **循环处理**：
    - 数据依次经过一系列过滤器的处理和传递，直到到达最终目的地或完成所有处理。
**特点**
- **模块化**：
    - 各过滤器是独立的处理单元，可以单独开发、测试和维护。
- **可组合性**：
    - 可以灵活地组合不同的过滤器来形成复杂的数据处理流水线。
- **高可复用性**：
    - 过滤器的独立性使其可以在不同的管道中复用。
**优点**
- **简单明了**：
    - 清晰的数据处理流程，易于理解和维护。
- **高可复用性**：
    - 过滤器模块可以在不同的管道配置中复用。
- **易扩展**：
    - 可以方便地添加、移除或替换过滤器，扩展系统功能。
**缺点**
- **性能开销**：
    - 数据在过滤器之间传递时，可能会有额外的性能开销。
- **数据一致性**：
    - 在并行处理的情况下，需要确保数据的一致性和正确性。
- **调试复杂性**：
    - 由于数据在多个过滤器之间流动，可能会增加调试的复杂性。
**适用场景**
- **数据流处理**：如日志处理、数据转换和格式化。
- **数据管道**：如ETL（Extract, Transform, Load）流程。
- **编译器设计**：如编译器的词法分析、语法分析和代码生成阶段。

**事件驱动风格**
系统中的行为由事件触发和响应来驱动。
**核心概念**
1. **事件**：
    - 某种状态变化或操作发生的信号。
    - 事件可以是用户动作、系统状态变化或外部系统通知。
2. **事件发布者（Event Publishers）**：
    - 生成并发布事件的组件。
    - 发布者只负责发出事件，不关心谁会处理这些事件。
3. **事件订阅者（Event Subscribers）**：
    - 接收并处理事件的组件。
    - 订阅者注册自己感兴趣的事件，并在事件发生时进行处理。
4. **事件通道（Event Channel）**：
    - 传递事件的中介或消息总线。
    - 负责在发布者和订阅者之间传递事件，确保事件能够到达所有感兴趣的订阅者。
**工作流程**
1. **事件发生**：
    - 系统中的某个操作或状态变化触发了事件。
2. **事件发布**：
    - 事件发布者将事件发布到事件通道。
3. **事件传递**：
    - 事件通道将事件传递给所有注册了该事件的订阅者。
4. **事件处理**：
    - 事件订阅者接收到事件后，执行相应的处理逻辑。
**特点**
- **松耦合**：
    - 事件发布者和订阅者之间没有直接依赖，通过事件通道进行通信。
- **灵活性和扩展性**：
    - 方便添加新的事件发布者和订阅者，系统具有高灵活性和可扩展性。
- **异步处理**：
    - 事件的处理通常是异步的，有助于提高系统的响应性和吞吐量。
**优点**
- **高松耦合**：
    - 组件之间的依赖性低，有助于系统的模块化和维护。
- **灵活性**：
    - 容易添加新功能或修改现有功能，而不影响其他组件。
- **异步性**：
    - 提高了系统的响应速度和可伸缩性。
**缺点**
- **调试复杂性**：
    - 由于组件之间的松耦合和异步性，调试和排查问题可能比较困难。
- **性能开销**：
    - 事件传递和处理的开销可能会影响系统性能，尤其是在高并发情况下。
- **事件管理**：
    - 需要有效的事件管理和处理机制，确保事件不丢失或重复处理。
**适用场景**
- **用户界面系统**：如基于GUI的应用程序，用户动作触发事件。
- **实时系统**：如监控系统、交易系统，需要实时响应事件。
- **分布式系统**：如微服务架构，通过事件进行服务间通信。

**C2 体系风格（低频考点）**
C2 体系风格强调基于组件和连接件的结构，主要用于构建用户界面密集型的分布式系统。
![[Pasted image 20240707195822.png]]
**核心概念**
1. **组件（Components）**：
    - 独立的计算实体，包含系统的功能逻辑。
    - 组件通过接口与其他组件进行交互。
2. **连接件（Connectors）**：
    - 负责组件之间的通信。
    - 连接件通过消息传递实现组件之间的解耦和交互。
3. **消息（Messages）**：
    - 组件之间通过发送和接收消息进行通信。
    - 分为请求消息和通知消息。
4. **层次结构（Hierarchical Structure）**：
    - 组件和连接件构成了一个层次化的结构。
    - 高层组件可以通过连接件访问低层组件，低层组件不能直接访问高层组件。
**工作流程**
1. **组件发送消息**：
    - 高层组件通过连接件发送请求消息给低层组件。
2. **消息传递**：
    - 连接件负责将消息从发送组件传递到接收组件。
3. **组件处理消息**：
    - 接收组件处理收到的消息，并可能生成响应消息或进一步的通知消息。
4. **消息返回**：
    - 响应消息通过连接件传递回原发送组件或其他相关组件。
**特点**
- **松耦合**：
    - 组件通过连接件进行通信，实现了松耦合，便于系统的扩展和维护。
- **层次化结构**：
    - 强调组件的层次化组织，高层组件可以通过连接件访问低层组件，但低层组件不能直接访问高层组件。
- **灵活性和可扩展性**：
    - 组件和连接件的独立性和层次化结构使系统具有高灵活性和可扩展性。
**优点**
- **模块化**：
    - 系统由独立的组件和连接件构成，便于模块化开发和维护。
- **灵活性**：
    - 易于添加、删除或替换组件和连接件，系统具有高灵活性。
- **可扩展性**：
    - 可以通过添加新组件或连接件来扩展系统功能。
**缺点**
- **复杂性**：
    - 层次化结构和消息传递机制增加了系统的复杂性。
- **性能开销**：
    - 消息传递和处理的开销可能会影响系统性能，尤其是在高并发情况下。
**适用场景**
- **用户界面密集型应用**：如图形用户界面系统、交互式应用程序。
- **分布式系统**：需要松耦合和灵活扩展的分布式系统。
- **实时系统**：需要实时响应和处理的系统。

**解释器风格（虚拟机）**
用于设计可以解析和执行特定语言或指令集的系统。该风格将程序代码分为解释器和被解释的程序两部分，解释器负责逐行解析并执行程序代码。
**核心概念**
1. **解释器（Interpreter）**：
    - 解析并执行特定语言或指令集的组件。
    - 包含词法分析、语法分析和执行引擎等子组件。
2. **被解释程序（Program）**：
    - 用特定语言或指令集编写的代码。
    - 作为解释器的输入进行解析和执行。
3. **词法分析器（Lexer）**：
    - 将输入程序的源代码转换为一系列标记（Tokens）。
4. **语法分析器（Parser）**：
    - 将标记序列转换为语法树（Parse Tree）或抽象语法树（Abstract Syntax Tree, AST）。
5. **执行引擎（Execution Engine）**：
    - 通过遍历语法树或抽象语法树来执行程序。
**工作流程**
1. **词法分析**：
    - 词法分析器将源代码解析为标记序列。
2. **语法分析**：
    - 语法分析器将标记序列转换为语法树或抽象语法树。
3. **执行**：
    - 执行引擎遍历语法树或抽象语法树，并执行相应的指令。
**特点**
- **动态执行**：
    - 程序在运行时被逐行解析和执行，可以方便地修改和调试。
- **高灵活性**：
    - 解释器可以支持多种语言或指令集，通过修改解释器可以支持新的功能。
- **即时反馈**：
    - 由于程序是逐行执行的，错误可以即时反馈，便于调试。
**优点**
- **易于调试和修改**：
    - 由于程序逐行解析和执行，调试和修改变得更为简单。
- **灵活性高**：
    - 解释器可以方便地扩展以支持新的语言特性或指令集。
- **平台无关性**：
    - 解释器可以在不同平台上运行，只需针对特定平台实现解释器。
**缺点**
- **性能较低**：
    - 解释器逐行解析和执行代码，通常比编译后的代码运行速度慢。
- **复杂性**：
    - 实现一个高效、功能完整的解释器可能较为复杂。
**适用场景**
- **脚本语言**：如Python、Ruby、JavaScript等。
- **嵌入式系统**：需要动态解析和执行指令的系统。
- **开发工具**：如集成开发环境（IDE）中的调试器。

**闭环风格（Closed-Loop Control Style）**
闭环风格，通常称为闭环控制系统，是一种在自动化和控制系统中的架构风格，用于描述系统通过反馈回路进行自我调节的控制机制。该风格广泛应用于工业控制、自动驾驶、航空航天等领域。
**核心概念**
1. **传感器（Sensors）**：
    - 监测系统的输出变量，并将测量结果反馈给控制器。
2. **控制器（Controller）**：
    - 接收传感器的反馈信息，与设定点（Setpoint）进行比较，计算出控制误差，并生成相应的控制信号。
3. **执行器（Actuators）**：
    - 接收控制信号并执行相应的动作，以调整系统的输入变量，使输出变量达到或保持在设定点。
4. **反馈回路（Feedback Loop）**：
    - 由传感器、控制器和执行器组成的闭环路径，用于不断修正系统的输出。
**工作流程**
1. **测量阶段**：
    - 传感器监测系统的输出变量，并将测量值反馈给控制器。
2. **比较和计算阶段**：
    - 控制器将实际测量值与期望设定点进行比较，计算出控制误差。
3. **控制信号生成阶段**：
    - 控制器根据控制算法（如PID控制算法），生成相应的控制信号。
4. **执行和调整阶段**：
    - 执行器接收控制信号，调整系统的输入变量，使输出变量趋近设定点。
5. **反馈阶段**：
    - 经过调整后的系统输出再次被传感器测量，并反馈给控制器，形成闭环控制。
**特点**
- **实时性**：
    - 系统能够实时监测和调整输出变量，以应对动态变化。
- **自适应性**：
    - 通过反馈机制，系统可以自我调节，适应不同的工作条件和环境变化。
- **高精度**：
    - 能够通过不断修正误差，实现高精度的控制效果。
**优点**
- **精确控制**：
    - 反馈回路能够不断修正误差，实现对系统输出的精确控制。
- **稳定性**：
    - 闭环控制系统能够有效应对外部扰动和系统内部的不确定性，保持系统稳定运行。
- **自动化程度高**：
    - 系统能够自动调节和优化，提高了自动化水平和工作效率。
**缺点**
- **复杂性**：
    - 设计和实现闭环控制系统需要考虑传感器、控制器和执行器的协调工作，系统复杂度较高。
- **调试和维护**：
    - 需要专业知识和经验进行系统的调试和维护，确保控制算法和反馈回路的准确性。
**适用场景**
- **工业自动化**：如自动化生产线中的温度、压力和流量控制。
- **自动驾驶**：如车辆的速度和方向控制。
- **航空航天**：如飞行器的姿态和轨迹控制。
- **家用电器**：如空调的温度控制和洗衣机的水位控制。

**调用返回风格**
也称为子程序调用风格。这种风格基于传统的程序设计方法，其中一个程序模块调用另一个程序模块，并在该模块执行完毕后返回到调用模块继续执行。
**核心概念**
1. **模块（Modules）**：
    - 独立的程序单元，每个模块执行特定的任务或功能。
2. **调用（Call）**：
    - 一个模块（调用者）请求执行另一个模块（被调用者）的操作，并等待其完成。
3. **返回（Return）**：
    - 被调用模块完成操作后，将控制权返回给调用模块。
4. **控制流（Control Flow）**：
    - 程序的执行流程通过调用和返回在不同模块之间传递。
**工作流程**
1. **调用模块执行**：
    - 调用模块开始执行，当需要其他模块的功能时，发出调用请求。
2. **被调用模块执行**：
    - 被调用模块接收到请求后开始执行其任务。
3. **任务完成后返回**：
    - 被调用模块执行完毕后，将结果返回给调用模块，并将控制权交还。
4. **调用模块继续执行**：
    - 调用模块接收到返回结果后，继续执行后续的操作。
**特点**
- **顺序执行**：
    - 调用和返回的过程是顺序进行的，一个调用完成后才能继续执行后续操作。
- **明确的控制流**：
    - 程序的执行顺序和控制流通过调用和返回机制清晰地定义。
- **模块化设计**：
    - 系统可以分解为多个模块，每个模块执行独立的功能，便于理解和维护。
**优点**
- **简单明了**：
    - 调用返回风格符合大多数程序设计语言的基本执行模型，简单易懂。
- **模块化**：
    - 系统功能分解为独立的模块，易于开发和维护。
- **可重用性**：
    - 各个模块可以独立开发和测试，提高了代码的可重用性。
**缺点**
- **同步执行**：
    - 调用模块必须等待被调用模块执行完毕，无法同时进行多个操作。
- **堆栈开销**：
    - 调用返回机制依赖于调用堆栈，深层次的调用可能导致堆栈溢出或性能问题。
- **耦合性**：
    - 模块之间的调用关系较为紧密，增加了模块间的耦合度。
**适用场景**
- **传统软件开发**：如桌面应用程序和命令行工具。
- **函数调用**：任何需要明确的调用返回机制的场景，如数学计算函数库。
- **面向对象编程**：类的方法调用和返回。

##### 8 .软件架构复用
软件架构复用的类型包括机会复用和系统复用，机会复用是指开发过程中，只要发现有可复用的资产，就对其进行复用。系统复用是指在开发之前，就要进行规划，以决定哪些需要复用。

##### 9.DSSA（Domain Specific Software Architecture）
DSSA 以一个特定问题领域为对象，形成由<u>领域参考模型、参考需求、参考架构</u>等组成的开发基础架构，旨在支持一个特定领域中多个应用的生成。  
DSSA 通常是一个具有三个层次的系统模型，包括<u>领域开发环境、领域特定应用开发环境和应用执行环境</u><u>。领域架构师在领域开发环境工作，应用工程师在领域特定的应用开发环境工作，操作员在应用执行环境工作。</u>
DSSA 基本活动包括<u>领域分析、领域设计和领域实现</u>。  
- <u>领域分析的主要目的是获得领域模型</u>，描述领域中系统之间共同的需求，即领域需求。  
- <u>领域设计的主要目标是获得 DSSA</u>，描述领域模型中表示需求的解决方案。  
- 领域实现的主要目标是依据领域模型和 DSSA 开发和组织可重用信息，并对基础软件架构进行实现。
参与 DSSA 的人员包括<u>领域专家、领域分析人员、领域设计人员和领域实现人员</u>，他们各自扮演不同的角色，负责领域工程中的不同方面。
领域专家的主要任务是提供有关领域中系统需求规格和实现知识，维护领域字典和复审领域模型和 DSSA 等。
领域分析人员则负责整个领域分析过程控制以及将从领域专家处获得的知识组织到领域模型中等。
领域设计人员则需要根据领域模型和现有系统开发出 DSSA 以及建立领域模型和 DSSA 之间的联系。
领域实现人员的任务是根据领域模型和 DSSA 进行软件实现以及对可重用构件进行验证。

##### 10.软件系统质量属性（Quality Attribute）
运行期质量属性包括<u>性能、安全性、易用性、可伸缩性、互操作性、可靠性、持续可用性和鲁棒性</u>。  
开发期质量属性包括<u>易理解性、可扩展性、可重用性，可测试性、可维护性和可移植性</u>。  
可伸缩性指当用户数和数据量增加时，软件系统维持高服务质量的能力。  
可维护性是指当需要修改缺陷、增加功能、提高质量属性时，定位修改点并实施修改的难易程度。
**常见架构策略**
性能：增加计算资源、减少计算开销、引入并发机制、采用资源调度等。
可用性：心跳、Ping/Echo、主动冗余、被动冗余、选举等。
可修改性：接口-实现分离、抽象、信息隐藏等。
安全性：追踪审计、抵抗攻击、检测攻击和从攻击中恢复

##### 11.质量属性场景（Quality Attribute Scenario）
质量属性场景是利益相关者和系统交互的简短陈述，由<u>刺激源、刺激、环境、制品、响应和响应度量</u>六部分组成。  
其中，刺激源是生成该刺激的实体，刺激是刺激到达系统时可能产生的影响，环境是该刺激在某条件内发生，制品是系统中受刺激的部分，响应是刺激到达后所采取的行动，响应度量是对响应的度量，用于测试需求是否满足。
此外，根据不同的质量属性，质量属性场景的刺激也有所不同，其中可用性为错误，修改性为增加/删除/修改/改变，性能为定期事件、随机时间、偶然事件，安全性为试图显示数据、改变/删除数据、访问系统服务、降低系统服务的可用性，易用性为学习系统特性、有效使用系统、使错误影响最低、适配系统、对系统满意；

##### 12 .敏感点和权衡点
- **敏感点（Sensitivity Point）**：敏感点是指一个或多个构件的特性，它们对特定质量属性有显著影响。例如，系统中某个模块的处理速度对整体性能的影响很大，那么这个模块的处理速度就是一个敏感点。
- **权衡点（Trade-off Point）**：权衡点是指影响多个质量属性的特性，是多个质量属性的敏感点。权衡点涉及到在提升一个质量属性的同时，可能会对另一个质量属性产生负面影响。例如，加密级别的改变既影响安全性，也影响性能。提高加密级别可以增强安全性，但会增加处理时间，降低性能。因此，这种设计决策就成为一个权衡点。

##### 13.物联网层次架构
物联网的三层结构包括感知层（负责识别物体、采集信息）、网络层（负责传递和处理信息）、应用层（解决信息处理与人机交互问题）。层次型架构风格是将系统划分为多个层，每个层次具有特定的功能，各层次之间通过接口进行通信，能够提高系统模块化程度、降低耦合度、便于维护和修改。

##### 14.特定领域架构 DSSA 的划分
特定领域架构 DSSA 可以分为<u>垂直域和水平域</u>。垂直域定义了一个特定的系统族，包含整个系统族内的多个系统，结果是在该领域中可作为系统的可行解决方案的一个通用软件体系结构。而水平域则定义了在多个系统和多个系统族中功能区城的共有部分，其范围在子系统级上涵盖多个系统族的特定部分功能。在特定领域架构中，垂直域关注的是与行业相关的，聚焦于行业特性的内容，而水平域关注的是各行业共性部分的内容。

##### 15.质量属性
**性能**是指系统的响应能力，代表参数是响应时间和吞吐量，常用的设计策略包括优先级队列和资源调度。  
**可用性**是指系统能够正常运行的时间比例，代表参数是故障间隔时间，常用的设计策略有冗余和心跳线。  
**安全性**是指系统在向合法用户提供服务的同时能够阻止非授权用户使用的企图或拒绝服务的能力，常用的设计策略是追踪审计。  
**可修改性**是指系统快速进行修改的能力，常用的策略是信息隐藏。  
**可靠性**是指在意外或错误使用的情况下维持软件系统的功能特性的基本能力，代表参数是 MTTF 和 MTBF（可靠性那块必须掌握），常用的设计策略有冗余和心跳线。

##### 16.三层 C/S 体系结构
三层 C/S 体系结构包括表示层、功能层和数据层三个部分。
- 表示层作为用户接口，用于输入和输出数据。
- 功能层是应用的核心，负责具体业务处理逻辑。
- 数据层是数据库管理系统，负责管理数据读写。
这种架构解决了应用程序复杂性和开发效率之间的矛盾，使得不同层的构建相互独立，接口简洁，适合于复杂事务处理。

##### 17.分层架构
层次化架构具有低耦合、依赖关系简单等特点，上层只能依赖于下层，底层错误将导致整个系统无法运行，而上层错误只会影响错误的这一部分。其次，系统风险威胁利用了脆弱性而引起，而脆弱性是系统内部的薄弱点。
**优点**
1. **模块化**：功能明确，易于理解和维护。
2. **松耦合**：各层独立，修改某层不影响其他层。
3. **重用性**：通用功能封装在低层，多次重用。
4. **可替换性**：可替换某层实现，不影响整体。
5. **可维护性**：问题定位和修复更方便。
6. **分布式开发**：团队并行开发，提高效率。
**缺点**
1. **性能开销**：层次传递和处理增加开销。
2. **复杂性**：层数多时管理复杂。
3. **层间依赖**：接口设计不合理时导致紧耦合。
4. **不灵活**：严格层次划分在需求变化时不灵活。
5. **过度设计**：对小型项目而言可能显得冗余。

##### 18.信息隐蔽
信息隐蔽是开发整体程序结构时使用的法则，即将每个程序的成分隐蔽或封装在一个单一的设计模块中，并且尽可能少地暴露其内部的处理。  
通常将难的决策、可能修改的决策、数据结构的内部连接以及对它所做的操作细节、内部特征码、与计算机硬件有关的细节等隐蔽起来。  
<u>通过信息隐蔽可以提高软件的可修改性、可测试性和可移植性，它也是现代软件设计的一个关键性原则。</u>

##### 19.EAI（Enterprise Application Integration，企业应用集成）
EAI 可以建立统一标准的基础平台，连接各种具有不同功能和目的的企业内部应用系统，以达到信息和流程的共享。EAI 的基本原则是集成多个系统并保证系统独立性，实施 EAI 必须遵循应用程序独立性、面向商业流程、独立于技术和平台无关等原则。<u>EAI 提供四个层次的服务，从下至上依次为通信服务、信息传递与转化服务、应用连接服务和流程控制服务。</u>

##### 20.面向服务的架构（SOA ）
常用的设0计模式是<u>服务注册表模式和企业服务总线 ESB 模式</u>。ESB 的目的是提供一种标准的软件底层架构，使各种程序组件能以<u>服务单元</u>的方式插入平台并以标准的消息通信方式交互。ESB 支持异构环境中的服务以及<u>基于消息和事件驱动模式</u>的交互，并具有适当的服务质量和可管理性。它的交互过程采用了事件驱动的消息交互模式，从而使组件之间的依赖关系得以解耦，并降低了软件系统互连的复杂性。ESB不支持服务请求者与服务提供者之间的直接连接，但二者之间存在松耦合的关系。

##### 21.基于体系结构的开发模型（ABSDM）
ABSDM 把整个基于体系结构的软件过程划分为体系结构需求、设计、文档化、复审、实现和演化等 6 个过程。
- 体系结构需求过程，其目的是获取用户需求和标识系统中所需要的构件。  
- 体系结构设计过程是一个迭代过程，可以使用已有的系统适用于大部分开发需求。  
- 体系结构文档化过程，并提到其主要输出物包括体系结构规格说明和质量设计说明书。  
- 体系结构复审，其目的是早期发现设计中的缺陷和错误。在一个主版本的软件架构分析之后，要安排一次由外部人员（用户代表和领域专家）参加的复审。  
- 体系结构实现过程，其过程是以文档化的体系结构说明书为基础的，并且每个构件必须满足其责任。  
- 体系结构演化，使用系统演化步骤对应用程序进行修改，以适应新的需求情况。

##### 22.领域专用软件体系结构（domain-specific software architecture，DSSA）
DSSA 以一个特定问题领域为对象，形成由领域参考模型、参考需求、参考架构等组成的开发基础架构，旨在支持一个特定领域中多个应用的生成。DSSA 基本活动包括领域分析、领域设计和领域实现。  
- 领域分析的主要目的是获得领域模型，描述领域中系统之间共同的需求，即领域需求。  
- 领域设计的主要目标是获得 DSSA，描述领域模型中表示需求的解决方案。  
- 领域实现的主要目标是依据领域模型和DSSA开发和组织可重用信息，并对基础软件架构进行实现。

##### 23.ATAM（Architecture Tradeoff Analysis Method）主要活动领域
**ATAM** 的重点是 **识别和评估架构风险**。它使用 **质量属性效用树** 来将抽象的质量属性分解为更具体的、可衡量的属性。然后，通过将架构决策映射到质量属性效用树，可以识别出架构的 **风险点** 和 **敏感点**。
其树形结构从根部到叶子节点依次为树根、质量属性、属性分类，质量属性场景。
ATAM 被分为四个主要的活动领域（或阶段），分别是<u>场景和需求收集、体系结构视图和场景实现、属性模型构造和分析、折中</u>。

##### 24.SAAM（Scenarios-based Architecture Analysis Method）主要输入
**SAAM** 的重点是 **评估架构满足特定系统需求的能力**。它使用 **场景** 来描述系统的预期行为。然后，架构师会评估架构是否满足每个场景的要求。
SAAM 分析评估体系结构的过程包括五个步骤，即<u>场景开发、体系结构描述、单个场景评估、场景交互和总体评估</u>。SAAM 的主要输入问题是问题描述、需求声明和体系结构描述。
SAAM 的主要输入是问题描述、需求声明和架构描述。

##### 25.架构描述语言
架构描述语言，基本构成要素包括组件、组件接口、连接件和架构配置。组件是计算或数据存储单元，在架构中可能大小不一。连接件建立组件间的交互和规则。架构配置描述了组件和连接件的连接图。

##### 26.软件系统架构 (了解)
软件系统架构是关于软件系统的结构、行为和属性的高级抽象。在描述阶段，主要描述直接构成系统的抽象组件以及各个组件之间的连接规则，特别是相对细致地描述组件之间的交互关系。在实现阶段，这些抽象组件被细化为实际的组件，比如具体类或者对象。软件系统架构不仅指定了软件系统的组织结构和拓扑结构，而且显示了系统需求和构成组件之间的对应关系，包括设计决策的基本方法和基本原理。
软件系统架构的 **目标** 是：
- 确保系统满足其 **需求**
- 使系统 **易于理解**、**开发**、**维护** 和 **扩展**
- 提高系统的 **质量属性**，例如性能、安全性和可维护性
软件系统架构通常包含以下 **元素**：
- **组件**：系统的基本构建块。组件可以是物理的（例如硬件设备）或逻辑的（例如软件模块）。
- **连接**：组件之间的通信方式。连接可以是同步的或异步的，可以是本地或远程的。
- **配置**：定义系统行为的属性和值。配置可以是静态的或动态的。
软件系统架构通常使用 **架构图** 来描述。架构图是一种可视化表示，显示系统的组件、连接和配置。

##### 27. 编译器
传统的编译器通常采用数据流架构风格，其中每个构件都有一组输入和输出。（这里要注意的是默认传统编译器都是管道过滤器风格，此题选择批处理单纯是因为它提到了整体传输的点，参看 16 年类似考题，芝士架构搜索编译器可以知道）处理程序源代码时，将源代码分步处理并产生目标代码，这与数据流架构风格相当符合（有的同学会疑惑为啥不是仓库风格，其实仓库风格和数据共享风格是一个意思）。由于 IDE 环境中多种工具围绕同一数据进行处理，因此适合采用数据共享架构风格。IDE 环境中多种功能的同时触发，这是典型的隐式调用风格（事件驱动系统）。“使IDE能够生成符合新操作系统要求的运行代码”，这一要求是可以通过适配策略满足，形成一致的接口。“模拟新操作系统的运行环境”是典型的虚拟机架构风格的特长。

##### 28.系统架构评估方法
SAEM 方法将软件架构视为最终产品和设计过程中的中间产品。它从外部和内部质量属性两个角度进行评估，创建了一个基础框架，用于规约建模、创建度量准则和评估质量属性。

SAABNet 方法使用贝叶斯信念网络（Bayesian Belief Networks, BBN）来表达和使用定性知识，辅助架构的定性评估。

软件架构修改度量方法（Software Architecture Change Measurement Method, SACMM）专注于软件架构在修改过程中的变化。它基于图内核定义差异度量准则，计算两个软件架构之间的距离，从而描述架构在修改过程中的转换模型。

软件架构静态分析方法（Static Analysis of Software Architecture Model, SASAM）通过映射和比较预期架构和实际架构来静态地评估软件架构。

软件架构可靠性风险评估方法（Architecture-based Reliability Risk Assessment, ALRRA）使用动态复杂度和耦合度准则来定义组件和连接件的复杂性因素，结合失效模式和影响分析（FMEA）来定义故障引起的后果的严重性因素，从而评估软件架构的可靠性风险。

层次分析法（Analytical Hierarchy Process, AHP）是一种多准则决策方法，它通过划分问题层次、构造比较判断矩阵、计算合成权重等步骤，帮助解决软件架构评估中的冲突问题，并对设计方案进行整体排名。

COSMIC+UML 方法是一种基于面向对象系统源代码的可维护性度量准则的方法，它通过将面向对象的度量准则与COSMIC方法相关联，并提出UML组件图的度量准则，来评估软件架构的可维护性。

##### 29.可靠性计算
MTBF 故障间隔时间，第一次故障到第二次故障的间隔时间。MTTF 平均无故障时间。MTTR 平均故障修理时间。这里比较 MTTF和MTBF的关系，看下图就知道，如果 MTTR 很小，MTTF ≈ MTBF。可靠性相关的软件质量属性包括容错（故障时确保正常行为）和健壮性（错误输入时按预定义方式终止）。
![[Pasted image 20240711103225.png]]

##### 30.CDN 和反向代理
CDN 和反向代理的基本原理都是缓存，区别在于 CDN 部署在网络提供商的机房，使用户在请求网站服务时，可以从距离自己最近的网络提供商机房获取数据； 而反向代理则部署在网站的中心机房，当用户请求到达中心机房后，首先访问的服务器反向代理服务器，如果反向代理服务器中缓存着用户请求的资源，就将其直接返回给用户。

##### 31.批处理和管道风格的对比
批处理是每个处理步骤是一个单独的程序，每一步必须在前一步结束后才能开始，并且数据必须是完整的，以整体的方式传递。它的基本构件是独立的应用程序，连接件是某种类型的媒介。管道过滤风格把系统分解为几个处理步骤，这些步骤之间通过数据流连接，一个步骤的输出是另一个步骤的输入。每个处理步骤由一个过滤器实现，处理步骤之间的数据传输由管道负责。每个处理步骤（过滤器）都有一组输入和输出，过滤器从管道中读取输入的数据流，经过内部处理，然后产生输出数据流并写入管道中。基本构件是过滤器，连接件是数据流传输管道。管道过滤风格支持并行。
![[Pasted image 20240711115236.png]]

##### 32. 区块链
区块链可被通俗地理解为一个分布式的公共“账本”，这个“账本”由各个区块连成一个链条。在传统记账系统中，记账权掌握在中心服务器手中。而在区块链这个“账本”上，链条上的每个节点都能记录信息，构成点对点的记账系统。因此，区块链技术被认为是一种去中心化的技术。公有链是公有区块链的简称，私有链是私有区块链的简称，联盟链则是联盟区块链的简称。

##### 33. 数字孪生（了解）
数字孪生生态系统由基础支撑层、数据互动层、模型构建层与仿真分析层、共性应用层以及行业应用层。
基础支撑层：涉及物联网终端设备，如芯片和传感器，负责数据采集和发送。主要供应商包括高通、英特尔、ARM、AMD、三星、英伟达、谷歌、华为和阿里等。
数据互动层：包括数据采集、传输和处理。数据采集通常通过DCS、PLC系统和智能仪表进行。数字孪生模型是动态的，需要实时数据上传、低延迟信息传输和处理，以及虚拟实体与物理实体间的实时动态映射。
模型构建与仿真分析层：提供数据建模、仿真和控制服务。核心技术包括测绘扫描、几何建模等，主要由国有测绘企业主导。仿真业务需要建立物理对象的数字化模型，并预测其未来状态，包括工业仿真软件和复杂系统仿真软件。
共性应用层：涵盖描述、诊断、预测和决策四个方面，需要软件定义的工具和平台支持，例如Bentley的iTwin Service、ANSYS的TwinBuilder、微软Azure和达索的3D Experience等。
行业应用层：数字孪生技术在智慧城市、交通、水利、工程、工业生产、能源、自动驾驶和公共应急等领域的应用服务，市场规模庞大，有超过1000家供应商。

##### 34. 物联网
物联网是指通过信息传感设备，按约定的协议，将任何物体与网络相连接，物体通过信息传播媒介进行信息交换和通信，以实现智能化识别、定位、跟踪、监管等功能。物联网应用通常分为三层，分别是<u>感知层、网络传输层和操作系统层</u>。

##### 35.软件复用
软件复用的基本过程，它包括三个主要阶段：
（1）构造/获取可复用的软件资产：这些资产需要是可靠的、广泛适用的、易于理解和修改的。
（2）管理可复用资产：构件库是支持软件复用的关键设施，它应提供构件的存储、管理、检索，以及库的浏览与维护等功能。这个阶段还包括构件的分类和检索，以便于快速准确地找到所需的构件。
（3）使用可复用资产：在最后一个阶段，开发者从构件库中获取所需的可复用资产，并根据特定需求进行定制、修改、扩展或配置，最终将这些资产组装和集成，形成满足需求的应用系统。

##### 36.三层 C/S 结构
与两层C/S 结构相比，三层C/S 结构增加了一个应用服务器。整个应用逻辑驻留在应用服务器上，只有表示层存在于客户机上，故称为“瘦客户机”。应用功能分为表示层、功能层和数据层三层。表示层是应用的用户接口部分，通常使用图形用户界面；功能层是应用的主体，实现具体的业务处理逻辑；数据层是数据库管理系统。以上三层逻辑上独立。
**三层 C/S 架构概述**
三层C/S架构将应用程序划分为三个独立的层次：
1. **表示层（Presentation Layer）**：用户界面，处理用户输入和输出。
2. **逻辑层（Logic Layer）**：应用程序的业务逻辑和规则。
3. **数据层（Data Layer）**：数据存储和管理，通常是数据库。
**调用返回风格的基本特征**
1. **模块化**：系统被分解为多个独立的模块，每个模块负责特定的功能。
2. **调用和返回**：一个模块调用另一个模块的功能，并在该模块执行完毕后返回结果。
3. **顺序执行**：调用是同步的，即调用者必须等待被调用者完成后才能继续执行。
**三层C/S架构与调用返回风格的对应关系**
1. **模块化**：
    - 三层架构将系统分为表示层、逻辑层和数据层，每层都可以视为一个独立的模块，负责特定的任务。
2. **调用和返回**：
    - **表示层调用逻辑层**：当用户在表示层进行操作时，表示层会调用逻辑层来处理业务逻辑。表示层发出请求（调用），逻辑层处理后返回结果。
    - **逻辑层调用数据层**：逻辑层需要访问或修改数据时，会调用数据层的功能。逻辑层发出数据请求（调用），数据层处理后返回结果。
3. **顺序执行**：
    - 调用是同步的。表示层等待逻辑层处理完业务逻辑后，才会继续执行下一步操作。同样，逻辑层等待数据层返回数据后，才会继续处理业务逻辑。

##### 37.Web 服务的基本协议
1. **UDDI（Universal Description, Discovery, and Integration）**
    - **描述**：用于描述、发现和集成Web服务的协议标准。
    - **功能**：提供统一的方式发布和搜索可用的Web服务信息。
    - **作用**：服务提供者可以在UDDI注册表中注册Web服务，服务使用者可以通过UDDI查找和连接这些服务。
2. **WSDL（Web Services Description Language）**
    - **描述**：用于描述Web服务接口的XML格式语言。
    - **功能**：定义Web服务的功能、输入输出参数、绑定协议和访问端点等信息。
    - **作用**：WSDL文件帮助服务使用者了解如何调用和使用Web服务。
3. **SOAP（Simple Object Access Protocol）**
    - **描述**：基于XML的消息传输协议，用于在Web服务之间进行通信。
    - **功能**：定义消息格式、编码规则和RPC（Remote Procedure Call）约定。
    - **作用**：通过各种应用层协议（如HTTP、SMTP等）传输SOAP消息，在应用程序之间交换结构化信息。
**总结**
- **UDDI** 提供了一个统一的注册和查找Web服务的机制。
- **WSDL** 定义了Web服务的详细接口和使用方法。
- **SOAP** 作为传输协议，负责Web服务之间的通信。


